<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PolyFire: Mobile Battle Royale (RTDB)</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    
    <style>
        :root {
            --primary: #00e5ff;
            --danger: #ff4081;
            --hud-bg: rgba(0, 0, 0, 0.6);
        }
        
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            height: 100vh;
            width: 100vw;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* --- UI OVERLAYS --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; 
        }

        .pointer-events-auto { pointer-events: auto; }

        /* --- LOBBY SCREEN --- */
        #lobby-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0d1b2a 0%, #1b263b 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            padding: 2.5rem;
            border-radius: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            max-width: 90%;
            width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        h1 { margin: 0 0 0.5rem 0; color: var(--primary); text-transform: uppercase; letter-spacing: 3px; font-size: 2rem; }
        p { color: #8899ac; margin-bottom: 2rem; }
        
        input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 16px;
            text-align: center;
            transition: border-color 0.3s;
        }
        input:focus { border-color: var(--primary); outline: none; }

        button {
            width: 100%;
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            border: none;
            background: var(--primary);
            color: black;
            font-weight: 800;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: transform 0.1s, background 0.3s;
        }

        button:active { transform: scale(0.95); }
        button:hover { background: #00b8cc; }

        #status-msg {
            margin-top: 15px;
            color: #ff4081;
            font-size: 12px;
            min-height: 20px;
        }

        /* --- HUD --- */
        #hud { display: none; width: 100%; height: 100%; }

        .top-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
        }

        .stat-box {
            background: var(--hud-bg);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #health-bar-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 240px;
            height: 20px;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #444;
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff1744, #d50000);
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 4px black;
        }
        #crosshair::before { top: 11px; left: 0; width: 24px; height: 2px; }
        #crosshair::after { top: 0; left: 11px; width: 2px; height: 24px; }

        /* Kill Feed */
        #kill-feed {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
            align-items: flex-end;
        }
        .feed-item {
            background: linear-gradient(90deg, rgba(0,0,0,0), rgba(0,0,0,0.8));
            color: white;
            font-size: 13px;
            padding: 6px 12px;
            border-radius: 4px;
            border-right: 3px solid var(--danger);
            animation: fadeOut 5s forwards;
        }
        @keyframes fadeOut {
            0% { opacity: 0; transform: translateX(20px); }
            10% { opacity: 1; transform: translateX(0); }
            80% { opacity: 1; }
            100% { opacity: 0; display: none; }
        }

        /* --- CONTROLS LAYER --- */
        #controls-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: auto;
            display: none; 
        }

        #zone-move { position: absolute; bottom: 0; left: 0; width: 40%; height: 50%; }
        #zone-aim { position: absolute; top: 0; right: 0; width: 60%; height: 100%; }

        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            display: none;
            pointer-events: none;
        }
        #joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .btn-action {
            position: absolute;
            border-radius: 50%;
            background: rgba(0,0,0,0.4);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            transition: background 0.1s;
        }
        .btn-action:active { background: rgba(255,255,255,0.2); transform: scale(0.95); }

        #btn-fire {
            bottom: 60px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: rgba(255, 64, 129, 0.4);
            border-color: #ff4081;
            font-size: 14px;
        }

        #btn-jump { bottom: 160px; right: 30px; width: 60px; height: 60px; font-size: 12px; }
        #btn-reload { bottom: 30px; right: 130px; width: 50px; height: 50px; font-size: 10px; }
        #btn-scope { bottom: 130px; right: 110px; width: 50px; height: 50px; font-size: 10px; }

        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 30px;
            height: 30px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        #hit-marker::before, #hit-marker::after { content: ''; position: absolute; background: #ff4081; box-shadow: 0 0 5px #ff4081; }
        #hit-marker::before { top: 14px; left: 0; width: 30px; height: 3px; }
        #hit-marker::after { top: 0; left: 14px; width: 3px; height: 30px; }

        #respawn-screen {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20, 0, 0, 0.85);
            z-index: 50;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        #rotate-warning {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--primary);
            text-align: center;
        }
        @media screen and (orientation: portrait) { #rotate-warning { display: flex; } }
    </style>
    
    <!-- Three.js 0.160 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
</head>
<body>

    <div id="rotate-warning">
        <h1 style="font-size: 4rem; margin-bottom: 0;">↻</h1>
        <h2>ROTATE DEVICE</h2>
        <p>Landscape Mode Required</p>
    </div>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="hit-marker"></div>

        <div id="hud">
            <div class="top-bar">
                <div class="stat-box">FPS: <span id="fps-counter">60</span></div>
                <div class="stat-box" id="ammo-display">30 / ∞</div>
            </div>
            <div id="health-bar-container"><div id="health-fill"></div></div>
            <div id="kill-feed"></div>
        </div>

        <div id="lobby-screen">
            <div class="panel">
                <h1>POLYFIRE</h1>
                <p>REAL-TIME SERVER EDITION</p>
                <input type="text" id="username-input" placeholder="CODENAME" maxlength="12">
                <button id="btn-join">CONNECT</button>
                <div id="status-msg"></div>
            </div>
        </div>

        <div id="respawn-screen">
            <h1 style="color: #ff4081; font-size: 3rem; margin:0;">ELIMINATED</h1>
            <p id="killer-msg" style="color: #ccc; font-size: 1.2rem;">by Unknown</p>
            <button id="btn-respawn" style="background: white; color: black; width: 220px; margin-top:30px;">RESPAWN (5s)</button>
        </div>
    </div>

    <div id="controls-layer">
        <div id="zone-move"></div>
        <div id="zone-aim"></div>
        <div id="joystick-base"><div id="joystick-stick"></div></div>
        <div id="btn-fire" class="btn-action">FIRE</div>
        <div id="btn-jump" class="btn-action">JUMP</div>
        <div id="btn-reload" class="btn-action">R</div>
        <div id="btn-scope" class="btn-action">ADS</div>
    </div>

<script type="module">
    // --- FIREBASE REALTIME DATABASE CONFIG ---
    const firebaseConfig = {
        apiKey: "AIzaSyAIK1h8MQw2SzYAcfPnb4ThqBYq8p5skF8",
        authDomain: "flyingmodi.firebaseapp.com",
        projectId: "flyingmodi",
        storageBucket: "flyingmodi.firebasestorage.app",
        messagingSenderId: "313784310367",
        appId: "1:313784310367:web:3db52f84943b98ae8b99ea",
        measurementId: "G-78CS1X69YG",
        // Using correct default RTDB URL format. If your DB is in a different region, update this.
        databaseURL: "https://flyingmodi-default-rtdb.firebaseio.com" 
    };

    // Using stable 10.7.1 version
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import { getDatabase, ref, set, onValue, update, remove, onDisconnect, push, child, get } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app); 

    // --- GAME CONSTANTS ---
    const GAME_CONFIG = {
        MAX_HP: 100, 
        MOVE_SPEED: 8,
        SPRINT_SPEED: 14,
        JUMP_FORCE: 12,
        GRAVITY: 25,
        SENSITIVITY: 0.003,
        WEAPON: {
            damageBody: 15,
            damageHead: 40,
            fireRate: 100,
            range: 1000,
            ammo: 30
        }
    };

    // --- GLOBAL STATE ---
    let username = "Guest";
    let isGameActive = false;
    let localPlayerId = null;
    let camera, scene, renderer;
    
    let localPlayer = {
        mesh: null,
        head: null,
        parts: {},
        velocity: new THREE.Vector3(),
        isGrounded: false,
        hp: GAME_CONFIG.MAX_HP,
        ammo: GAME_CONFIG.WEAPON.ammo,
        lastShot: 0,
        isDead: false,
        color: new THREE.Color().setHSL(Math.random(), 0.8, 0.5).getHex()
    };
    
    const remotePlayers = {}; 
    const colliders = []; 
    
    const inputs = {
        move: { x: 0, y: 0 },
        look: { x: 0, y: 0 },
        fire: false, jump: false, ads: false
    };

    // --- AUDIO ---
    let audioCtx;
    function playSound(type) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        if (type === 'shoot') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'hit') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(800, now);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.05);
            osc.start(now); osc.stop(now + 0.05);
        }
    }

    // --- THREE.JS ENGINE ---
    function init3D() {
        const container = document.getElementById('game-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 20, 80);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(1024, 1024);
        scene.add(dirLight);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(200, 200);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        colliders.push(floor);
        
        const grid = new THREE.GridHelper(200, 50, 0x444444, 0x333333);
        scene.add(grid);

        // Obstacles
        const boxGeo = new THREE.BoxGeometry(4, 4, 4);
        const boxMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        for(let i=0; i<40; i++) {
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.set((Math.random()-0.5)*160, 2, (Math.random()-0.5)*160);
            box.castShadow = true;
            box.receiveShadow = true;
            scene.add(box);
            colliders.push(box);
        }

        createLocalPlayer();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // --- PLAYER FACTORY ---
    function createHumanoidModel(color) {
        const group = new THREE.Group();
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
        const shirtMat = new THREE.MeshStandardMaterial({ color: color });
        const pantsMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

        // Body Parts
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), skinMat);
        head.position.y = 1.65; head.castShadow = true;
        head.userData = { part: 'head' };
        group.add(head);

        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.75, 0.3), shirtMat);
        torso.position.y = 1.0; torso.castShadow = true;
        torso.userData = { part: 'body' };
        group.add(torso);

        const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.7, 0.18), skinMat);
        leftArm.position.set(-0.4, 1.0, 0); group.add(leftArm);
        
        const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.7, 0.18), skinMat);
        rightArm.position.set(0.4, 1.0, 0); rightArm.rotation.x = -0.5; rightArm.position.z = 0.2; group.add(rightArm);

        const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.85, 0.22), pantsMat);
        leftLeg.position.set(-0.15, 0.425, 0); group.add(leftLeg);
        
        const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.85, 0.22), pantsMat);
        rightLeg.position.set(0.15, 0.425, 0); group.add(rightLeg);

        // Gun
        const gun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.6), new THREE.MeshStandardMaterial({ color: 0x111 }));
        gun.position.set(0, -0.3, 0.3);
        rightArm.add(gun);

        return { mesh: group, head, leftLeg, rightLeg, leftArm, rightArm };
    }

    function createNameLabel(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 64;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.beginPath(); ctx.roundRect(0, 0, 256, 64, 10); ctx.fill();
        ctx.font = 'bold 36px Arial'; ctx.fillStyle = '#fff';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, 128, 32);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
        sprite.position.y = 2.8; sprite.scale.set(2, 0.5, 1);
        return sprite;
    }

    function createLocalPlayer() {
        const model = createHumanoidModel(localPlayer.color);
        localPlayer.mesh = model.mesh;
        localPlayer.head = model.head;
        localPlayer.parts = { lLeg: model.leftLeg, rLeg: model.rightLeg, lArm: model.leftArm };
        scene.add(localPlayer.mesh);
        localPlayer.head.add(camera);
        camera.position.set(0, 0, 0); 
    }

    function createRemotePlayer(id, data) {
        if(remotePlayers[id]) return; 
        
        const model = createHumanoidModel(data.color || 0xff0000);
        model.mesh.traverse(c => { if(c.isMesh) c.userData.id = id; }); 
        model.head.userData.part = 'head'; 

        model.mesh.add(createNameLabel(data.username));
        scene.add(model.mesh);

        remotePlayers[id] = {
            mesh: model.mesh,
            parts: { lLeg: model.leftLeg, rLeg: model.rightLeg },
            targetPos: new THREE.Vector3(data.x, data.y, data.z),
            targetRot: data.ry,
            data: data
        };
        addFeedItem(data.username + " connected");
    }

    // --- NETWORKING ---
    function showStatus(msg) {
        document.getElementById('status-msg').innerText = msg;
    }

    function joinGame() {
        const input = document.getElementById('username-input');
        if(!input.value) return input.focus();
        username = input.value;
        localStorage.setItem('polyfire_username', username);

        const btn = document.getElementById('btn-join');
        btn.disabled = true;
        btn.innerText = "CONNECTING...";
        showStatus("Authenticating...");

        // Try Anon Auth
        signInAnonymously(auth).then(() => {
            showStatus("Auth Success. Connecting to Game Server...");
        }).catch(error => {
            console.error(error);
            showStatus("Auth Error: " + error.message + ". Check Firebase Console > Auth > Sign-in method.");
            btn.disabled = false;
            btn.innerText = "CONNECT";
        });

        onAuthStateChanged(auth, user => {
            if(user) {
                localPlayerId = user.uid;
                connectToRealtimeDB();
            }
        });
    }

    function connectToRealtimeDB() {
        const playersRef = ref(db, 'players');
        const myRef = ref(db, 'players/' + localPlayerId);
        
        // Monitor Connection
        const connectedRef = ref(db, '.info/connected');
        onValue(connectedRef, (snap) => {
            if (snap.val() === true) {
                console.log("Connected to RTDB");
                showStatus("Connected!");
                document.getElementById('lobby-screen').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('controls-layer').style.display = 'block';
                
                // Set Up Player
                init3D();
                initInputs();
                startRenderLoop();
                isGameActive = true;

                onDisconnect(myRef).remove(); 
                set(myRef, {
                    username: username,
                    color: localPlayer.color,
                    hp: 100,
                    x: 0, y: 0, z: 0, ry: 0,
                    lastFired: 0
                }).catch(e => {
                    console.error("Write failed: ", e);
                    alert("Database Write Failed! Check Firebase Rules.");
                });

            } else {
                showStatus("Connecting to Database...");
            }
        });

        // Listen for World Updates
        onValue(playersRef, (snapshot) => {
            const players = snapshot.val() || {};
            
            Object.keys(players).forEach(key => {
                if (key === localPlayerId) {
                    const myData = players[key];
                    if (myData.hp < localPlayer.hp) {
                        localPlayer.hp = myData.hp;
                        updateHealthUI();
                        playSound('hit');
                        if(localPlayer.hp <= 0 && !localPlayer.isDead) die(myData.lastAttacker);
                    }
                    return;
                }

                const pData = players[key];
                if (!remotePlayers[key]) {
                    createRemotePlayer(key, pData);
                } else {
                    const rp = remotePlayers[key];
                    rp.targetPos.set(pData.x, pData.y, pData.z);
                    rp.targetRot = pData.ry;
                    
                    if (pData.lastFired > (rp.data.lastFired || 0)) {
                        playSound('shoot');
                        const origin = new THREE.Vector3(pData.x, pData.y + 1.2, pData.z); 
                        const direction = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0,1,0), pData.ry);
                        const target = origin.clone().add(direction.multiplyScalar(50));
                        createBulletTrace(origin, target);
                    }
                    rp.data = pData;
                }
            });

            Object.keys(remotePlayers).forEach(key => {
                if (!players[key]) {
                    scene.remove(remotePlayers[key].mesh);
                    delete remotePlayers[key];
                    addFeedItem("Player left");
                }
            });
        });

        // Send Updates
        setInterval(() => {
            if(!isGameActive || localPlayer.isDead) return;
            
            update(myRef, {
                x: Number(localPlayer.mesh.position.x.toFixed(2)),
                y: Number(localPlayer.mesh.position.y.toFixed(2)),
                z: Number(localPlayer.mesh.position.z.toFixed(2)),
                ry: Number(localPlayer.mesh.rotation.y.toFixed(2)),
                lastFired: localPlayer.lastShot
            }).catch(e => {
                // Silent catch, usually auth/rules issue
            });
        }, 80);
    }

    // --- ACTIONS ---
    async function shoot() {
        const now = Date.now();
        if (now - localPlayer.lastShot < GAME_CONFIG.WEAPON.fireRate) return;
        localPlayer.lastShot = now; 
        playSound('shoot');

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        
        const targets = [];
        Object.values(remotePlayers).forEach(rp => {
            rp.mesh.traverse(c => { if(c.isMesh) targets.push(c); });
        });
        colliders.forEach(c => targets.push(c));

        const intersects = raycaster.intersectObjects(targets);
        const start = localPlayer.head.getWorldPosition(new THREE.Vector3());
        let end = raycaster.ray.at(100, new THREE.Vector3());

        if (intersects.length > 0) {
            const hit = intersects[0];
            end = hit.point;
            const obj = hit.object;

            if (obj.userData.id) {
                const isHead = obj.userData.part === 'head';
                const dmg = isHead ? GAME_CONFIG.WEAPON.damageHead : GAME_CONFIG.WEAPON.damageBody;
                
                showHitMarker();
                if(isHead) console.log("HEADSHOT");

                const victimRef = ref(db, 'players/' + obj.userData.id);
                get(child(victimRef, 'hp')).then((snap) => {
                    if(snap.exists()) {
                        const currentHp = snap.val();
                        update(victimRef, { 
                            hp: currentHp - dmg,
                            lastAttacker: username
                        });
                    }
                });
            }
        }
        createBulletTrace(start, end);
    }

    function createBulletTrace(start, end) {
        const geom = new THREE.BufferGeometry().setFromPoints([start, end]);
        const line = new THREE.Line(geom, new THREE.LineBasicMaterial({ color: 0xffff00 }));
        scene.add(line);
        setTimeout(() => { scene.remove(line); geom.dispose(); }, 50);
    }

    function showHitMarker() {
        const el = document.getElementById('hit-marker');
        el.style.opacity = 1;
        playSound('hit');
        setTimeout(() => el.style.opacity = 0, 100);
    }

    function updateHealthUI() {
        const pct = Math.max(0, (localPlayer.hp / GAME_CONFIG.MAX_HP) * 100);
        document.getElementById('health-fill').style.width = pct + '%';
    }

    function addFeedItem(text) {
        const div = document.createElement('div');
        div.className = 'feed-item';
        div.innerText = text;
        document.getElementById('kill-feed').prepend(div);
        if(document.getElementById('kill-feed').children.length > 4) 
            document.getElementById('kill-feed').lastChild.remove();
    }

    function die(killer) {
        localPlayer.isDead = true;
        document.getElementById('respawn-screen').style.display = 'flex';
        document.getElementById('killer-msg').innerText = `Eliminated by ${killer || "Enemy"}`;
        document.getElementById('controls-layer').style.display = 'none';
        
        let cd = 5;
        const btn = document.getElementById('btn-respawn');
        btn.disabled = true;
        const iv = setInterval(() => {
            cd--; btn.innerText = `RESPAWN (${cd}s)`;
            if(cd<=0) { clearInterval(iv); btn.disabled=false; btn.innerText="DEPLOY"; btn.onclick=respawn; }
        }, 1000);
    }

    function respawn() {
        localPlayer.isDead = false;
        localPlayer.hp = GAME_CONFIG.MAX_HP;
        updateHealthUI();
        const x = (Math.random()-0.5)*100;
        const z = (Math.random()-0.5)*100;
        localPlayer.mesh.position.set(x, 0, z);
        update(ref(db, 'players/'+localPlayerId), { hp: 100, x, z });
        document.getElementById('respawn-screen').style.display = 'none';
        document.getElementById('controls-layer').style.display = 'block';
    }

    // --- GAME LOOP ---
    function updatePlayer(dt) {
        if(localPlayer.isDead) return;
        const mesh = localPlayer.mesh;

        mesh.rotation.y -= inputs.look.x * GAME_CONFIG.SENSITIVITY;
        const head = localPlayer.head;
        head.rotation.x -= inputs.look.y * GAME_CONFIG.SENSITIVITY;
        head.rotation.x = Math.max(-1.5, Math.min(1.5, head.rotation.x));

        const fwd = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), mesh.rotation.y);
        const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), mesh.rotation.y);
        
        const move = new THREE.Vector3();
        move.addScaledVector(fwd, -inputs.move.y);
        move.addScaledVector(right, inputs.move.x);
        if(move.length() > 0) move.normalize();

        const speed = inputs.ads ? GAME_CONFIG.MOVE_SPEED/2 : GAME_CONFIG.MOVE_SPEED;
        localPlayer.velocity.x = move.x * speed;
        localPlayer.velocity.z = move.z * speed;
        localPlayer.velocity.y -= GAME_CONFIG.GRAVITY * dt;

        if(localPlayer.isGrounded && inputs.jump) {
            localPlayer.velocity.y = GAME_CONFIG.JUMP_FORCE;
            localPlayer.isGrounded = false;
            inputs.jump = false;
            playSound('jump');
        }

        mesh.position.addScaledVector(localPlayer.velocity, dt);
        if(mesh.position.y < 0) { mesh.position.y=0; localPlayer.velocity.y=0; localPlayer.isGrounded=true; }

        const camZ = inputs.ads ? 1.5 : 4;
        const camX = inputs.ads ? 0.4 : 1.5;
        camera.position.set(camX, 0.5, camZ);

        const isMoving = move.lengthSq() > 0.1;
        if(isMoving) {
            const t = Date.now() * 0.015;
            localPlayer.parts.lLeg.rotation.x = Math.sin(t)*0.6;
            localPlayer.parts.rLeg.rotation.x = Math.sin(t+Math.PI)*0.6;
        } else {
            localPlayer.parts.lLeg.rotation.x = 0;
            localPlayer.parts.rLeg.rotation.x = 0;
        }
    }

    function startRenderLoop() {
        const clock = new THREE.Clock();
        const loop = () => {
            requestAnimationFrame(loop);
            const dt = Math.min(clock.getDelta(), 0.1);
            updatePlayer(dt);
            Object.values(remotePlayers).forEach(rp => {
                rp.mesh.position.lerp(rp.targetPos, 0.2);
                rp.mesh.rotation.y += (rp.targetRot - rp.mesh.rotation.y) * 0.2;
                if(rp.mesh.position.distanceTo(rp.targetPos) > 0.1) {
                    const t = Date.now() * 0.015;
                    rp.parts.lLeg.rotation.x = Math.sin(t)*0.6;
                    rp.parts.rLeg.rotation.x = Math.sin(t+Math.PI)*0.6;
                }
            });
            if(inputs.fire) shoot();
            if('ontouchstart' in window) {
                inputs.look.x *= 0.6; inputs.look.y *= 0.6;
            } else {
                inputs.look.x *= 0.1; inputs.look.y *= 0.1; 
            }
            renderer.render(scene, camera);
            document.getElementById('fps-counter').innerText = Math.round(1/dt);
        };
        loop();
    }

    function initInputs() {
        document.addEventListener('click', e => {
            if(e.target.id === 'game-container') document.body.requestPointerLock();
        });
        document.addEventListener('mousemove', e => {
            if(document.pointerLockElement) {
                inputs.look.x += e.movementX * 0.2; inputs.look.y += e.movementY * 0.2;
            }
        });
        document.addEventListener('mousedown', e => {
            if(document.pointerLockElement) {
                if(e.button===0) inputs.fire=true; if(e.button===2) inputs.ads=true;
            }
        });
        document.addEventListener('mouseup', e => {
            if(e.button===0) inputs.fire=false; if(e.button===2) inputs.ads=false;
        });
        window.addEventListener('keydown', e => {
            if(e.code==='KeyW') inputs.move.y = -1;
            if(e.code==='KeyS') inputs.move.y = 1;
            if(e.code==='KeyA') inputs.move.x = -1;
            if(e.code==='KeyD') inputs.move.x = 1;
            if(e.code==='Space') inputs.jump = true;
        });
        window.addEventListener('keyup', e => {
            if(['KeyW','KeyS'].includes(e.code)) inputs.move.y = 0;
            if(['KeyA','KeyD'].includes(e.code)) inputs.move.x = 0;
            if(e.code==='Space') inputs.jump = false;
        });

        const zoneMove = document.getElementById('zone-move');
        const stick = document.getElementById('joystick-stick');
        const base = document.getElementById('joystick-base');
        let moveId = null, startX, startY;

        zoneMove.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            moveId = t.identifier; startX = t.clientX; startY = t.clientY;
            base.style.display = 'block';
            base.style.left = (startX-60)+'px'; base.style.top = (startY-60)+'px';
            stick.style.transform = `translate(-50%, -50%)`;
        });
        zoneMove.addEventListener('touchmove', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === moveId) {
                    const t = e.changedTouches[i];
                    const dx = t.clientX - startX; const dy = t.clientY - startY;
                    const angle = Math.atan2(dy, dx);
                    const dist = Math.min(Math.hypot(dx, dy), 60);
                    const mx = Math.cos(angle)*dist; const my = Math.sin(angle)*dist;
                    stick.style.transform = `translate(calc(-50% + ${mx}px), calc(-50% + ${my}px))`;
                    inputs.move.x = mx/60; inputs.move.y = my/60;
                }
            }
        });
        const endMove = e => {
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === moveId) {
                    moveId = null; base.style.display = 'none'; inputs.move.x=0; inputs.move.y=0;
                }
            }
        };
        zoneMove.addEventListener('touchend', endMove);

        const zoneAim = document.getElementById('zone-aim');
        let aimId = null, lastAimX, lastAimY;
        zoneAim.addEventListener('touchstart', e => {
            if(e.target.classList.contains('btn-action')) return;
            const t = e.changedTouches[0];
            aimId = t.identifier; lastAimX = t.clientX; lastAimY = t.clientY;
        });
        zoneAim.addEventListener('touchmove', e => {
            e.preventDefault(); 
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === aimId) {
                    const t = e.changedTouches[i];
                    inputs.look.x = t.clientX - lastAimX;
                    inputs.look.y = t.clientY - lastAimY;
                    lastAimX = t.clientX; lastAimY = t.clientY;
                }
            }
        });
        zoneAim.addEventListener('touchend', e => { aimId=null; });

        const bindBtn = (id, prop) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', e=>{ e.preventDefault(); inputs[prop]=true; });
            el.addEventListener('touchend', e=>{ e.preventDefault(); inputs[prop]=false; });
        };
        bindBtn('btn-fire', 'fire');
        bindBtn('btn-jump', 'jump');
        
        document.getElementById('btn-scope').addEventListener('touchstart', e=>{
            e.preventDefault(); inputs.ads = !inputs.ads;
            e.target.style.background = inputs.ads ? 'rgba(255,255,255,0.8)' : 'rgba(0,0,0,0.4)';
        });
        document.getElementById('btn-reload').addEventListener('touchstart', e=>{
            e.preventDefault(); localPlayer.ammo = GAME_CONFIG.WEAPON.ammo;
        });
        
        const saved = localStorage.getItem('polyfire_username');
        if(saved) document.getElementById('username-input').value = saved;
        document.getElementById('btn-join').onclick = joinGame;
    }
</script>
</body>
</html>
